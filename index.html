<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Enhanced 3D ASCII CRT</title>
    <style>
        :root {
            /* --- CSS Variables for JS Control --- */
            --phosphor-color: #00FF41; /* Default Green */
            --glow-intensity-base: 8px; /* Controls max blur radius */
            --scanline-opacity: 0.6;
            --vignette-opacity: 0.5;
            --flicker-opacity: 0.03; /* How much the opacity changes */
            --crt-bg-color: #000;
            --container-perspective: 2000px; /* For curvature effect */
            --container-rotateX: 0deg;      /* For curvature effect */
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--crt-bg-color);
            color: var(--phosphor-color);
            font-family: 'Courier New', Courier, monospace;
            line-height: 1;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
            cursor: grab;
             /* Apply perspective for curvature effect */
            perspective: var(--container-perspective);
        }
         #container:active {
             cursor: grabbing;
        }

        /* The AsciiEffect output */
        #ascii-output {
            position: absolute;
            top:0; left:0; right:0; bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            width: 100%;
            height: 100%;
            font-size: 10px; /* Base size, effect resolution handles density */
            white-space: pre; /* Important for ASCII layout */
            background-color: transparent; /* Let body/container bg show */
            color: var(--phosphor-color); /* Set color via variable */
            transition: color 0.3s ease; /* Smooth color transitions */

             /* --- Glow Effect --- */
             /* Using calc() to scale glow with intensity variable */
            text-shadow:
                0 0 calc(var(--glow-intensity-base) * 0.4) var(--phosphor-color), /* Innermost, brightest */
                0 0 calc(var(--glow-intensity-base) * 0.8) rgba(from var(--phosphor-color) r g b / 0.6),
                0 0 calc(var(--glow-intensity-base) * 1.2) rgba(from var(--phosphor-color) r g b / 0.4),
                0 0 calc(var(--glow-intensity-base) * 1.8) rgba(from var(--phosphor-color) r g b / 0.2); /* Outermost, faintest */

            /* Make text unselectable */
            user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;

            /* --- Optional Curvature --- */
            transform: rotateX(var(--container-rotateX)); /* Controlled by JS */
            transition: transform 0.5s ease-out;

            /* --- Flicker Animation --- */
            animation: flicker 0.15s infinite alternate;
        }

        /* --- Scanline Overlay --- */
        #container::after {
            content: "";
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0) 0px, rgba(0, 0, 0, 0) 1px,
                rgba(0, 0, 0, 0.8) 2px, rgba(0, 0, 0, 0.8) 3px
            );
            opacity: var(--scanline-opacity); /* Controlled by JS */
            pointer-events: none;
            z-index: 1;
            transition: opacity 0.3s ease; /* Smooth transitions */
        }

         /* --- Vignette Overlay --- */
        #container::before {
            content: "";
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            box-shadow: inset 0 0 100px 50px rgba(0, 0, 0, var(--vignette-opacity)); /* Controlled by JS */
            pointer-events: none;
            z-index: 2;
            transition: box-shadow 0.3s ease; /* Smooth transitions */
        }

        /* --- Flicker Animation --- */
        @keyframes flicker {
            from { opacity: calc(1.0 - var(--flicker-opacity)); }
            to { opacity: 1.0; }
        }

        /* --- Styling for lil-gui --- */
        .lil-gui {
            --background-color: rgba(0, 0, 0, 0.7);
            --widget-color: #222;
            --title-background-color: #111;
            --text-color: var(--phosphor-color);
            --number-color: #0f0; /* Different color for numbers */
            --string-color: #0f0;
            --font-family: 'Courier New', Courier, monospace;
            --font-size: 11px;
            --input-font-size: 11px;
            --widget-padding: 2px;
            --widget-border-radius: 0px;
            --folder-indent: 5px;
             backdrop-filter: blur(3px); /* Slight blur behind GUI */
        }
        .lil-gui.root > .title {
             color: #fff;
             background-color: #004d00; /* Dark green title bar */
        }
         .lil-gui .controller.string input, .lil-gui .controller.number input {
            border: 1px solid #333;
            border-radius: 0;
         }
         .lil-gui .controller.color .display {
            border-radius: 0;
            border: 1px solid #444;
         }
         .lil-gui button {
            background-color: #1a1a1a;
             border: 1px solid #444;
             border-radius: 0;
             color: var(--phosphor-color);
         }
        .lil-gui button:hover {
            background-color: #333;
        }

        /* Loading Indicator */
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: var(--phosphor-color);
            font-size: 1.5em;
            z-index: 100;
            text-shadow: 0 0 5px var(--phosphor-color);
            animation: flicker 0.5s infinite alternate;
        }

    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.js"
            }
        }
    </script>
</head>
<body>
    <div id="loading">INITIALIZING CRT...</div>
    <div id="container">
        </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { AsciiEffect } from 'three/addons/effects/AsciiEffect.js';
        import GUI from 'lil-gui';

        // --- Global Variables ---
        let scene, camera, renderer, effect, controls, currentMesh, material;
        let gui;
        const container = document.getElementById('container');
        const loadingIndicator = document.getElementById('loading');
        const geometries = {}; // To store pre-made geometries

        // --- Parameters Object ---
        const params = {
            shape: 'Sphere',
            colorTheme: '#00FF41', // Green
            glowIntensity: 8,    // Base pixel value for CSS calc()
            scanlineOpacity: 0.6,
            vignetteOpacity: 0.5,
            asciiResolution: 0.18,
            asciiChars: ' .:-=+*#%@',
            animate: true,
            rotationSpeed: 0.005,
            crtCurvature: false,
            flickerIntensity: 0.03,
            reset: () => { gui.reset(); updateAllStyles(); } // Reset function
        };

        // --- Character Sets ---
        const charSets = {
            Detailed: ' .:-=+*#%@',
            Blocks: ' ░▒▓█',
            Symbols: ' .-oO0@',
            Lines: ' _|/=\\-'
        };

        // --- Color Themes ---
        const colorThemes = {
            Green: '#00FF41',
            Amber: '#FFB000',
            Blue: '#00BFFF',
            White: '#E0E0E0'
        };

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 10;

            // Renderer (needed for AsciiEffect)
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Note: Renderer's canvas is not added to DOM directly

            // Material (reused for all shapes)
            material = new THREE.MeshStandardMaterial({
                color: 0xffffff, // Always use white for best ASCII contrast
                roughness: 0.5,
                metalness: 0.1,
                flatShading: false
            });

            // Pre-create Geometries
            geometries.Sphere = new THREE.SphereGeometry(3, 32, 16);
            geometries.Torus = new THREE.TorusGeometry(2.5, 1, 16, 100);
            geometries.Box = new THREE.BoxGeometry(4, 4, 4);
            geometries.TorusKnot = new THREE.TorusKnotGeometry(2, 0.6, 100, 16);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xcccccc, 1.0);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // Create Initial Mesh
            updateGeometry(); // Uses default params.shape

             // AsciiEffect Setup
            createAsciiEffect();

            // Controls
            controls = new OrbitControls(camera, effect.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 4;
            controls.maxDistance = 25;
            controls.enablePan = false;

            // Setup GUI
            setupGUI();

            // Apply initial styles from params
            updateAllStyles();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);

            // Hide loading indicator
            loadingIndicator.style.display = 'none';
        }

         // --- Create or Recreate AsciiEffect ---
         function createAsciiEffect() {
            if (effect && effect.domElement) {
                container.removeChild(effect.domElement); // Remove old one if exists
            }
             effect = new AsciiEffect(renderer, params.asciiChars, {
                 invert: false,
                 resolution: params.asciiResolution,
                 scale: 1,
                 color: false, // Use CSS for color
                 alpha: false
             });
             effect.setSize(window.innerWidth, window.innerHeight);
             effect.domElement.style.backgroundColor = 'transparent'; // CSS handles bg
             effect.domElement.id = 'ascii-output'; // Assign ID for easier CSS targeting
             container.appendChild(effect.domElement);

             // Re-attach controls if effect element changes
             if(controls) {
                 controls.dispose(); // Clean up old listeners
                 controls = new OrbitControls(camera, effect.domElement);
                 // Re-apply control settings
                 controls.enableDamping = true;
                 controls.dampingFactor = 0.05;
                 controls.screenSpacePanning = false;
                 controls.minDistance = 4;
                 controls.maxDistance = 25;
                 controls.enablePan = false;
             }

            // Apply current styles immediately after creation
            updateColor();
            updateGlow();
            updateScanlines();
            updateVignette();
            updateCurvature();
            updateFlicker();
         }


        // --- Update Geometry ---
        function updateGeometry() {
            if (currentMesh) {
                scene.remove(currentMesh);
                currentMesh.geometry.dispose(); // Clean up old geometry
            }
            const geometry = geometries[params.shape];
            if (geometry) {
                currentMesh = new THREE.Mesh(geometry, material);
                scene.add(currentMesh);
            } else {
                console.error("Unknown shape:", params.shape);
            }
        }

        // --- Style Update Functions ---
        function updateColor() {
            document.documentElement.style.setProperty('--phosphor-color', params.colorTheme);
            // Also update GUI text color potentially
             document.documentElement.style.setProperty('--text-color', params.colorTheme);
             document.documentElement.style.setProperty('--number-color', params.colorTheme);
             document.documentElement.style.setProperty('--string-color', params.colorTheme);
        }
        function updateGlow() {
            document.documentElement.style.setProperty('--glow-intensity-base', `${params.glowIntensity}px`);
        }
        function updateScanlines() {
            document.documentElement.style.setProperty('--scanline-opacity', params.scanlineOpacity);
        }
        function updateVignette() {
            document.documentElement.style.setProperty('--vignette-opacity', params.vignetteOpacity);
        }
        function updateCurvature() {
            const rotateValue = params.crtCurvature ? '3deg' : '0deg';
            const perspectiveValue = params.crtCurvature ? '1500px' : '2000px';
            document.documentElement.style.setProperty('--container-rotateX', rotateValue);
            document.documentElement.style.setProperty('--container-perspective', perspectiveValue);
        }
         function updateFlicker() {
            document.documentElement.style.setProperty('--flicker-opacity', params.flickerIntensity);
        }
        // Function to update all styles at once (e.g., on reset)
        function updateAllStyles() {
            updateColor();
            updateGlow();
            updateScanlines();
            updateVignette();
            updateCurvature();
            updateFlicker();
        }


        // --- GUI Setup ---
        function setupGUI() {
            gui = new GUI({ title: 'CRT Controls'});
            gui.domElement.style.zIndex = "10"; // Ensure GUI is above overlays

            // Shape
            gui.add(params, 'shape', Object.keys(geometries)).name('Shape').onChange(updateGeometry);

            // Appearance Folder
            const appearance = gui.addFolder('Appearance');
            appearance.addColor(params, 'colorTheme', colorThemes).name('Color Theme').onChange(updateColor);
            appearance.add(params, 'glowIntensity', 0, 20, 0.5).name('Glow Intensity').onChange(updateGlow);
            appearance.add(params, 'scanlineOpacity', 0, 1, 0.05).name('Scanlines').onChange(updateScanlines);
            appearance.add(params, 'vignetteOpacity', 0, 1, 0.05).name('Vignette').onChange(updateVignette);
            appearance.add(params, 'flickerIntensity', 0, 0.1, 0.005).name('Flicker').onChange(updateFlicker);
            appearance.add(params, 'crtCurvature').name('CRT Curvature').onChange(updateCurvature);

            // ASCII Folder
            const ascii = gui.addFolder('ASCII Effect');
            ascii.add(params, 'asciiResolution', 0.05, 0.5, 0.01).name('Resolution').onChange(() => {
                // Recreate effect needed for resolution/chars change
                 createAsciiEffect();
            });
             ascii.add(params, 'asciiChars', charSets).name('Character Set').onChange(() => {
                 // Recreate effect needed for resolution/chars change
                 createAsciiEffect();
             });


            // Animation Folder
            const animation = gui.addFolder('Animation');
            animation.add(params, 'animate').name('Animate');
            animation.add(params, 'rotationSpeed', 0, 0.02, 0.001).name('Rotation Speed');

            // Reset Button
            gui.add(params, 'reset').name('Reset Defaults');
        }

        // --- Window Resize ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            effect.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Rotation
            if (params.animate && currentMesh) {
                currentMesh.rotation.y += params.rotationSpeed;
                currentMesh.rotation.x += params.rotationSpeed * 0.5; // Add some x rotation too
            }

            // Update controls
            controls.update();

            // Render using AsciiEffect
            effect.render(scene, camera);
        }

        // --- Start ---
        init();
        animate();

    </script>
</body>
</html>